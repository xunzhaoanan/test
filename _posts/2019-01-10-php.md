---
layout: post
title:  "PHP框架开发思路"
date:   2018-07-10 14:00:00
categories: PHP
tags: PHP
excerpt: 在用了一段时间PHP框架后，自己也想着手写一个精简版框架。前后断断续续经过大半年时间，终于有了小成果，并且成功在公司的项目中跑起来了。这里简单聊聊编写一个PHP框架的思路，欢迎交流。
---


* content
{:toc}

在用了一段时间PHP框架后，自己也想着手写一个精简版框架。
前后断断续续经过大半年时间，终于有了小成果，并且成功在公司的项目中跑起来了。
这里简单聊聊编写一个PHP框架的思路，欢迎交流。
（此篇文章以YII2框架为参考）。

## 框架初始化

框架里最重要的就是核心类（core class）了，核心类中最重要的就是基类了，类似于[YII2](https://www.yiichina.com/)框架里的`Application`类.
基类（后文称作`App`类）应该包含能启动框架的功能，它是与业务无关的。每次程序运行的时候，都会加载这个文件，一般在入口文件中被加载（带上配置参数）然后实例化。
下面聊聊`App`类初始化需要的一些功能。

### 初始化主要功能


#### 定义系统默认常量。

我们经常在入口文件中的第一行就看到开始一些系统常量的定义，在`App`类中，可以定义这些常量的默认值。


#### 类的自动加载

在使用PHP主流框架的过程中，当需要使用某个类的某个方法时，往往只需要**use**一下目标类的命名空间就行了，而不需要引入目标文件，
这在原生环境中是绝对不行的。那么框架是如何做到的呢？答案就是用到了PHP中的一个函数:[spl_autoload_register](http://www.php.net/manual/zh/function.spl-autoload-register.php)。
在YII2中，是这样使用的：

```php
spl_autoload_register(['Yii', 'autoload'], true, true);
```
    
这句话的意思是，当使用一个没有包含的类方法时，框架会定位到Yii类中的`autoload()`方法。在此方法中，把需要的类包含进来就可以了。   
此函数在手册中有详细的说明，在使用这个函数后，我们也能像其他框架那样自由使用类了。

        
#### 加载配置&组件

一般情况下，我们会有一个或多个配置文件，此配置文件一般以数组形式存放着系统变量和组件。
在入口文件实例化`App`类时，可以在初始化的时候加载这个配置文件，存放在类属性里，这样在程序任何地方，都可以使用到这个配置变量。
普通配置的使用比较简单，无非就是引用`App`类的某个属性，这里重点说一下组件的加载和使用。
参考一下YII2，一个典型的例子就是**数据库配置**。

我们写框架的时候，如果有组件这个概念，那么在使用框架的时候会方便许多，让我们先看看组件是怎么定义的：

```php
'components' => [
        'cache' => [
            'class' => 'yii\caching\FileCache',
        ],
        'db' => [
            'class' => 'yii\db\Connection',
            'dsn' => 'mysql:host=127.0.0.1;dbname=test',
            'username' => 'root',
            'password' => '',
            'charset' => 'utf8',
        ],
    ]
```

这是YII2框架中组件定义的方法，这个数组会在初始化的时候触发`setComponents()`函数，此函数如下：

```php
public function setComponents($components)
{
    foreach ($components as $id => $component) {
        $this->set($id, $component);
    }
}
```

$components变量就是上面定义的数组，`set()`方法会把我们的组件数组以键值对的方式放在ServiceLocator类的`_definitions`属性中，
当我们需要用到数据库的时候，通常会调用这个方法`Yii::$app->db`，其实Yii类中是不存在db这个变量的，此时会调用
核心类的`__get()`魔术方法，在`__get()`里调用ServiceLocator类`get()`方法。

`get()`方法通过获取初始化时注册在`_definitions`中的值，实例化了数据库数组中**class**元素值的类，也就是`yii\db\Connection`类，并且返回到`Yii::$app->db`，
从而我们就可以通过用`Yii::$app->db`调用`yii\db\Connection`类中的方法。其他组件也是类似这样去获取的。

所以，我们在自己的框架中也可以像YII2这样引入组件功能，可以不用那么复杂，先写个简单的。
用组件可以使配置统一管理，代码更加整洁；同时使OOP思想更加深刻，特别是在自己写框架时。

> 记得要定义一个实例化组件（对象）的方法（`createObject()`），放在`App`类中，在程序任何阶段都可以调用。

    
## run()
    
在初始化之后，就要执行`App`类中的`run()`方法进入业务代码了，此方法一般也是在入口文件调用，每次运行代码的时候都会执行一次，下面我们看看`run()`方法都有哪些功能。

### run()方法主要功能


#### 运行run()

`App`类定义的`run()`方法作为一个大入口，可以说整个业务代码的生命周期都在这个方法里。
注意`run()`方法要在`try{...}catch{...}`中完成，因为我们需要记录错误并处理。


    
#### 解析请求

要执行某个控制器里的某个方法，首先要做的是根据url解析到相应的方法上。解析请求看起来简单，其实根据框架功能丰富程度，也许会很复杂。
假设我们的访问地址如下：

```
http://127.0.0.1/index/update?id=1
```
    
* 获取`route`,也就是除主机名称和查询参数的值，即 `index/update`。

    > 注意url美化的问题，可以通过配置参数，在获取route的时候需要区分pathinfo模式或默认模式。上面的url为美化的url。
    
* 获取请求参数`params`，数组形式，即 `Array([id] => 1)`。

    > 对于美化的url，这个比较简单，可以直接使用PHP中的`$_GET`变量。

    
#### 实例化控制器

既然已经获取到了`route`，那么可以通过`app`类中的方法实例化**index**控制器了。

* 获取控制器ID，即 `index`；以及方法ID，即 `update`。
    
    > 自己写框架可以自己定义一套获取规则，一般情况下，在`route`中根据字符`/`分割出最后一个字符串就是方法ID，其余作为控制器ID。
      如果控制器ID中还带有`/`字符串，就在多module情况了，需要实现module组件化，最终目的是实例化自定义module（目录）下的控制器。

* 实例化控制器，这里可以使用[ReflectionClass](http://www.php.net/manual/en/reflectionclass.getinterfaces.php)函数。
   在`App`类中，将获取的控制器ID作为参数传入创建对象实例的函数中，在得到控制器的实例后，返回到核心类中，接下来需要用到。

    ```php
    $reflection = new ReflectionClass($class);
    $reflection->newInstanceArgs($args);
    ```
    > 在使用反射机制实例化一个类时，要注意命名空间是否正确，更好的做法是在配置中定义好控制器的命名空间，
      拼接到控制器ID前面，作为参数传入`ReflectionClass()`方法。

         
#### 执行控制器方法
    
在上面的步骤中，我们得到了一个控制器的实例、方法ID和请求参数，这里定义一个类似`YII2`中的`runAction()`的方法（`App`类中调用）。
在`runAction`中调用函数[call_user_func_array](http://php.net/manual/zh/function.call-user-func-array.php)。

根据前文的url，假设我们在实际项目中定义了一个**IndexController**的类，并且在此类中定义一个**update**的方法。这样，
我们只需要把前文得到的`IndexController`（object类型）、`update`（string类型）和`Array([id] => 1)`(array类型，注意数组格式需要转换成函数需要的)传入下面的函数就行了。

```php
return call_user_func_array([$this->controller, $this->actionMethod], $args);}
```

这个函数会执行传入类中的指定方法，这样我们框架就实现了根据路由定位到类方法的功能，

如果需要在执行方法前后做点什么，可以在控制器类（`IndexController`）的父类中（`controller`类）定义`beforeAction()`和`afterAction()`两个空方法，
然后在`controller`类调用`runActionWithParam()`的前后加入这两个方法。这样，当我们的`IndexController`中包含`beforeAction()`或`afterAction()`方法时，
就会通过PHP的重写机制，执行我们自己的定义的内容，大致如下：

```php
    //这里是controller类的runAction()方法
    //执行beforeAction()方法，这里$this为IndexController实例
    $this->beforeAction();
    //执行用户方法,这里$this为IndexController实例
    $this->runActionWithParam();
    //执行afterAction()方法，这里$this为IndexController实例
    $this->afterAction();
```

在`App`类中也可以按照这样做

```php
    //这里是App类的runAction()方法
    //运行控制器前置方法，这里$this为App实例
    $this->beforeRun();
    //运行控制器，这里$this为App实例,在此方法中，调用controller类runAction()方法
    $this->runAction();
    //运行控制器后置方法，这里$this为App实例
    $this->afterRun();
```


#### 输出结果

在执行了url中的类方法后，会得到一个返回结果，此时我们需要将返回结果经过一些处理后输出。
我们可以定义一个`response`类，在此类中定义在html中的一些元素，比如`Content-Type`、`charset`和`content`等等。
然后将返回结果赋值到`response`类的`content`属性上，经过一系列预处理后通过`response`类方法`send()`出来。
```php
    //前面的步骤可以整理header
    //这里是response类的send()部分方法，$this为response实例
    echo $this->content;
```

> 在渲染**视图**的时候，可能会用到各种前端框架或组件，这里不是本文讨论的重点，也就是说，
  本文所讲的框架更适合作为接口使用。


#### 错误监控

我们是在`App`类中执行`run()`方法的，作为入口，所以在这里加上代码的监控比较合适。
在代码的运行过程中，可能会出现系统或业务级错误，这个时候需要把错误记录下来并写入日志文件，必要时加入报警机制，方便及时处理。
所以正如前面所说，我们在运行`run()`方法时，需要用到`try{...}catch{...}`，这样在捕获到错误的时候，可以通过自定义方法处理。

```php
    //App类中的run()方法
    public function run()
    {
        try {
            //do something
        } catch (ExitException $e) {
            //这里自定义错误处理，$this为app实例
            $this->errorHandler($e);
        }
    }
```

这样通过`errorHandler()`方法，我们能够自定义处理框架监控到的整个业务代码所`throw`的错误。
但是这样还不够，也许在业务代码中，有一些运行中发生中错误并没有被`throw`（比如内存不足，磁盘满等等），这些虽然PHP会有报错，但是我们仍然需要捕获并写入日志，方便定位问题。
这里我们需要自定义PHP默认错误处理机制，方法就是注册异常，错误，退出处理函数，如下：

* [set_exception_handler()](http://www.php.net/manual/zh/function.set-exception-handler.php) - 设置默认的异常处理程序，用于没有用 try/catch 块来捕获的异常。
* [set_error_handler()](http://www.php.net/manual/zh/function.set-error-handler.php) - 设置用户自定义的错误处理函数。
* [register_shutdown_function()](http://php.net/manual/zh/function.register-shutdown-function.php) - 注册一个会在php中止时执行的函数，用于处理致命错误。

只要我们在上述函数中注册了自定义监控方法，那么框架里所有的错误类型我们都能处理，达到了监控整个程序流程的目的。

    
## 扩展

如果框架完成了前面所说的功能，那么现在其实可以简单的输出一些结果了。但是这是不够的，在业务中，往往会用到数据库、
    
